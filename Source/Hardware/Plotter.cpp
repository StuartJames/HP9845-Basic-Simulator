/*
 *        Copyright (c) 2020-2023 HydraSystems.
 *
 *  This program is free software; you can redistribute it and/or   
 *  modify it under the terms of the GNU General Public License as  
 *  published by the Free Software Foundation; either version 2 of  
 *  the License, or (at your option) any later version.             
 *                                                                  
 *  This program is distributed in the hope that it will be useful, 
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of  
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   
 *  GNU General Public License for more details.                    
 *                                                                  
 *
 *  Based on a design by Michael Haardt
 *
 * Edit Date/Ver   Edit Description
 * ==============  ===================================================
 * SJ   19/08/2020  Original
 *
 */

#include "stdafx.h"
#include "./Basic/BasicDefs.h"

//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////

CPlotter::CPlotter(void) : CDevice()
{
	m_InUserUnits = true;
}

//////////////////////////////////////////////////////////////////////

CPlotter::~CPlotter(void)
{
	delete m_pPlotterFont;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Initialise(void)
{
	m_pDoc = static_cast<CS45BasicDoc*>(g_pBasicDoc);
	m_pPlotterFont = new CHersheyFunctions(FALSE);
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Destroy(void)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::ResetParameters(void)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::ResetHardware(void)
{
}

//////////////////////////////////////////////////////////////////////

inline LONG CPlotter::xToDC(int PosX)
{
	return PosX;
}

//////////////////////////////////////////////////////////////////////

inline LONG CPlotter::xToDC(double PosX)
{
	return (int)PosX;
}

//////////////////////////////////////////////////////////////////////

inline LONG CPlotter::yToDC(int PosY)
{
	return PosY;
}

//////////////////////////////////////////////////////////////////////

inline LONG CPlotter::yToDC(double PosY)
{
	return (int)PosY;
}

//////////////////////////////////////////////////////////////////////

inline CPoint CPlotter::ToDC(CPointDbl Pos)
{
CPoint Point;

	Point.x = (int)Pos.x;
	Point.y = (int)Pos.y;
	return Point;
}

//////////////////////////////////////////////////////////////////////

inline CRectDbl CPlotter::ToDC(CRectDbl Rect)
{
	return Rect;
}

//////////////////////////////////////////////////////////////////////

inline CPointDbl CPlotter::ToUser(CPoint Pos)
{
CPointDbl Point;

	Point.x = (double)Pos.x;
	Point.y = (double)Pos.y;
	return Point;
}

//////////////////////////////////////////////////////////////////////

inline CRectDbl CPlotter::ToUser(CRectDbl Rect)
{
	return Rect;
}

//////////////////////////////////////////////////////////////////////

inline CRectDbl CPlotter::UDUtoPDU(CRectDbl Rect)
{
	return Rect;
}

//////////////////////////////////////////////////////////////////////

inline CPointDbl	CPlotter::RotatePoint(CPointDbl Pos)
{
	return Pos;
}

//////////////////////////////////////////////////////////////////////

inline CPoint	CPlotter::RotatePlot(CPointDbl Pos)
{
CPoint Point;

	Point.x = (int)Pos.x;
	Point.y = (int)Pos.y;
	return Point;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Locate(CRectDbl ToDC)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Axes(Axes_Grid_s Axes)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Clip(CRectDbl Clip)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::CSize(float CharSize, float m_CharRatio)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Frame(void)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::GClear(void)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::GPrint(const char *pBitStream, CPoint To, CSze Size, int Flag, int Offset)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Grid(Axes_Grid_s	Grid)
{
}

//////////////////////////////////////////////////////////////////////

int CPlotter::Label(BString *pStr)
{
	return DEV_OK;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::LDir(double Angle)
{
	m_LabelAngle = Angle;
}

//////////////////////////////////////////////////////////////////////

bool CPlotter::Limit(CRectDbl Limits)
{
	return false;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::LineType(int Type, int Length)
{
	m_LineType = Type;
	m_LineTypeLen = Length;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::LOrg(int Origin)
{
	m_LabelOrgn = Origin;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Move(CPointDbl To)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Pen(int Number)
{
}
//////////////////////////////////////////////////////////////////////

void CPlotter::PenUp(void)
{
	m_PenDown = false;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::PDir(double Angle)
{
	m_PlotAngle = Angle;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Plot(CPointDbl To, int PlotType, int PenCntrl)
{
}

//////////////////////////////////////////////////////////////////////

double CPlotter::Ratio(void)
{
	return 1.0;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Scale(CRectDbl ToDC)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::SetUnits(int Unit)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::SetPointer(CPointDbl To, int CursorType)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Show(CRectDbl Show)
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::Unclip(void)
{
}

CRectDbl CPlotter::GetClipRect(void)
{
	return m_HardClipRect;
}

//////////////////////////////////////////////////////////////////////

void CPlotter::ClipToSoft(void)	
{
}

//////////////////////////////////////////////////////////////////////

void CPlotter::ClipToHard(void)	
{
}


